/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  Glossary Terms â€” Data Loader & Utilities
 *
 *  Imports the pre-bundled all-terms.json (generated by
 *  scripts/bundle-glossary.mjs) and provides O(1) lookups,
 *  category grouping, alphabetical indexing, and cross-reference
 *  resolution.
 *
 *  Safe for BOTH server and client bundles (no fs dependency).
 *  Run `node scripts/bundle-glossary.mjs` after adding/changing
 *  term JSON files.
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

import type {
  GlossaryTerm,
  GlossaryTagMap,
  GlossaryCategory,
  AlphabetEntry,
  GlossaryTermSummary,
} from "@/types/glossary";

/* â”€â”€ Shared pure utility (re-exported for convenience) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
import { getTagDisplayName } from "@/lib/glossary/tag-names";
export { getTagDisplayName };

/* â”€â”€ Import pre-bundled data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

import allTermsJson from "@/data/glossary/all-terms.json";
import tagsJson from "@/data/glossary/tags.json";

/** All glossary terms, sorted alphabetically by primary name */
export const glossaryTerms: GlossaryTerm[] = allTermsJson as GlossaryTerm[];

/** Map of tag ID â†’ { accent, icon } */
export const glossaryTags: GlossaryTagMap = tagsJson as GlossaryTagMap;

/* â”€â”€ Lookup maps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

const termByIdMap = new Map<string, GlossaryTerm>(
  glossaryTerms.map((t) => [t.id, t]),
);

/** O(1) term lookup by id */
export function getTermById(id: string): GlossaryTerm | undefined {
  return termByIdMap.get(id);
}

/** Get terms by primary_tag */
export function getTermsByCategory(tag: string): GlossaryTerm[] {
  return glossaryTerms.filter((t) => t.primary_tag === tag);
}

/** Get all terms whose tags array includes the given tag */
export function getTermsByTag(tag: string): GlossaryTerm[] {
  return glossaryTerms.filter(
    (t) => t.primary_tag === tag || t.tags.includes(tag),
  );
}

/* â”€â”€ Categories â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

function buildCategories(): GlossaryCategory[] {
  const countMap = new Map<string, number>();
  for (const term of glossaryTerms) {
    countMap.set(term.primary_tag, (countMap.get(term.primary_tag) || 0) + 1);
  }

  const categories: GlossaryCategory[] = [];
  for (const [id, count] of countMap.entries()) {
    const tag = glossaryTags[id];
    categories.push({
      id,
      name: getTagDisplayName(id),
      count,
      accent: tag?.accent || "#6C5CE7",
      icon: tag?.icon || "ðŸ“š",
    });
  }

  // Sort by count descending, then name ascending
  categories.sort((a, b) => b.count - a.count || a.name.localeCompare(b.name));
  return categories;
}

/** All categories derived from term primary_tags, sorted by count */
export const glossaryCategories: GlossaryCategory[] = buildCategories();

/** O(1) category lookup by id */
const categoryByIdMap = new Map<string, GlossaryCategory>(
  glossaryCategories.map((c) => [c.id, c]),
);

export function getCategoryById(id: string): GlossaryCategory | undefined {
  return categoryByIdMap.get(id);
}

/* â”€â”€ Relationships â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/** Resolve see_also IDs to full term objects */
export function getRelatedTerms(term: GlossaryTerm): GlossaryTerm[] {
  if (!term.see_also?.length) return [];
  return term.see_also
    .map((id) => termByIdMap.get(id))
    .filter(Boolean) as GlossaryTerm[];
}

/** Resolve prerequisite IDs to full term objects */
export function getPrerequisiteTerms(term: GlossaryTerm): GlossaryTerm[] {
  if (!term.prerequisites?.length) return [];
  return term.prerequisites
    .map((id) => termByIdMap.get(id))
    .filter(Boolean) as GlossaryTerm[];
}

/* â”€â”€ Alphabet index â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

export function getAlphabetIndex(): AlphabetEntry[] {
  const map = new Map<string, GlossaryTerm[]>();

  for (const term of glossaryTerms) {
    const letter = term.names[0].charAt(0).toUpperCase();
    if (!map.has(letter)) map.set(letter, []);
    map.get(letter)!.push(term);
  }

  const entries: AlphabetEntry[] = [];
  // Add all 26 letters, even those with no terms
  for (let i = 65; i <= 90; i++) {
    const letter = String.fromCharCode(i);
    entries.push({
      letter,
      terms: map.get(letter) || [],
    });
  }

  // Add # for non-alpha starts
  const nonAlpha = glossaryTerms.filter(
    (t) => !/^[A-Z]/i.test(t.names[0]),
  );
  if (nonAlpha.length > 0) {
    entries.unshift({ letter: "#", terms: nonAlpha });
  }

  return entries;
}

/* â”€â”€ Navigation helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/** Get prev/next terms within the same primary_tag category */
export function getTermNavigation(term: GlossaryTerm): {
  prev: GlossaryTerm | null;
  next: GlossaryTerm | null;
} {
  const categoryTerms = getTermsByCategory(term.primary_tag);
  const idx = categoryTerms.findIndex((t) => t.id === term.id);
  return {
    prev: idx > 0 ? categoryTerms[idx - 1] : null,
    next: idx < categoryTerms.length - 1 ? categoryTerms[idx + 1] : null,
  };
}

/* â”€â”€ Static params â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/** All term slugs for generateStaticParams */
export function getAllTermSlugs(): string[] {
  return glossaryTerms.map((t) => t.id);
}

/** All category IDs for generateStaticParams */
export function getAllCategorySlugs(): string[] {
  return glossaryCategories.map((c) => c.id);
}

/* â”€â”€ Search / Lightweight summaries â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/** Set of all term IDs for fast membership testing (used by inline linker) */
export const allTermIds: Set<string> = new Set(
  glossaryTerms.map((t) => t.id),
);

/** Map of all names/aliases/abbr â†’ term id for inline linking */
export function buildTermNameMap(): Map<string, string> {
  const map = new Map<string, string>();
  for (const term of glossaryTerms) {
    for (const name of term.names) {
      map.set(name.toLowerCase(), term.id);
    }
    for (const alias of term.aliases || []) {
      map.set(alias.toLowerCase(), term.id);
    }
    // Skip very short abbreviations (2 chars) to avoid false positives
    for (const abbr of term.abbr || []) {
      if (abbr.length > 2) {
        map.set(abbr.toLowerCase(), term.id);
      }
    }
  }
  return map;
}

/** Lightweight term summaries for client-side search index */
export function getTermSummaries(): GlossaryTermSummary[] {
  return glossaryTerms.map((t) => ({
    id: t.id,
    name: t.names[0],
    aliases: t.aliases || [],
    abbr: t.abbr || [],
    definition: t.definition.slice(0, 200),
    primary_tag: t.primary_tag,
    tags: t.tags,
    level: t.level,
  }));
}

/* â”€â”€ Comparison pairs for "X vs Y" pages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

export interface ComparisonPair {
  /** Alphabetically sorted canonical slug: "termA-vs-termB" */
  slug: string;
  termA: GlossaryTerm;
  termB: GlossaryTerm;
}

function buildComparisonPairs(): ComparisonPair[] {
  const seen = new Set<string>();
  const pairs: ComparisonPair[] = [];

  for (const term of glossaryTerms) {
    if (!term.differentials?.length) continue;
    for (const diff of term.differentials) {
      if (!diff.id) continue;
      const other = termByIdMap.get(diff.id);
      if (!other) continue;

      const [a, b] = [term.id, other.id].sort();
      const key = `${a}|${b}`;
      if (seen.has(key)) continue;
      seen.add(key);

      pairs.push({
        slug: `${a}-vs-${b}`,
        termA: termByIdMap.get(a)!,
        termB: termByIdMap.get(b)!,
      });
    }
  }

  return pairs;
}

export const glossaryComparisonPairs: ComparisonPair[] = buildComparisonPairs();

const comparisonBySlug = new Map<string, ComparisonPair>(
  glossaryComparisonPairs.map((p) => [p.slug, p]),
);

/** Lookup a comparison pair by its canonical slug */
export function getComparisonPair(slug: string): ComparisonPair | undefined {
  return comparisonBySlug.get(slug);
}

/** All comparison slugs for generateStaticParams */
export function getAllComparisonSlugs(): string[] {
  return glossaryComparisonPairs.map((p) => p.slug);
}

/* â”€â”€ Symptom landing pages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

import { curatedSymptoms } from "@/data/glossary/symptoms";
import type { SymptomEntry } from "@/data/glossary/symptoms";
export type { SymptomEntry };
export { curatedSymptoms };

export interface SymptomPageData {
  symptom: SymptomEntry;
  matchingTerms: GlossaryTerm[];
}

function buildSymptomIndex(): Map<string, SymptomPageData> {
  const index = new Map<string, SymptomPageData>();

  for (const symptom of curatedSymptoms) {
    const matching = glossaryTerms.filter((term) => {
      if (!term.how_youll_see_it?.length) return false;
      const joined = term.how_youll_see_it.join(" ").toLowerCase();
      return symptom.keywords.some((kw) => joined.includes(kw));
    });

    if (matching.length > 0) {
      index.set(symptom.slug, { symptom, matchingTerms: matching });
    }
  }

  return index;
}

const symptomIndex = buildSymptomIndex();

/** Get all symptom slugs that have matching terms */
export function getAllSymptomSlugs(): string[] {
  return Array.from(symptomIndex.keys());
}

/** Lookup symptom page data by slug */
export function getSymptomPageData(slug: string): SymptomPageData | undefined {
  return symptomIndex.get(slug);
}

/** All symptom entries that have matching terms (for sitemap) */
export function getAllSymptomPages(): SymptomPageData[] {
  return Array.from(symptomIndex.values());
}

/* â”€â”€ Stats â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

export const glossaryStats = {
  totalTerms: glossaryTerms.length,
  totalCategories: glossaryCategories.length,
  premedTerms: glossaryTerms.filter((t) => t.level === "premed").length,
  medicalTerms: glossaryTerms.filter(
    (t) => !t.level || t.level === "physiological",
  ).length,
  formulaTerms: glossaryTerms.filter((t) => t.level === "formula").length,
  labValueTerms: glossaryTerms.filter((t) => t.level === "lab-value").length,
};
